[[https://towardsdev.com/event-loop-in-javascript-672c07618dc9|Ссылка на источник]]

# Цикл событий (Event Loop) в JavaScript

Цикл событий — это секрет асинхронного программирования в JavaScript. JS выполняет все операции в одном потоке, но с помощью нескольких умных структур данных создаёт иллюзию многопоточности. Асинхронное поведение не является частью самого языка JavaScript, а реализуется поверх его основной функциональности в браузере (или другой среде выполнения) и доступно через API браузера.

## Поток выполнения JavaScript в браузере и Node.js

Поток выполнения JavaScript в браузере, так же как и в Node.js, основан на цикле событий. Концепция цикла событий очень проста: существует бесконечный цикл, в котором движок JavaScript ожидает задачи, выполняет их, а затем снова засыпает, ожидая новых задач.

### Общий алгоритм работы движка:

1. Пока есть задачи — выполняем их, начиная с самой старой.
2. Спим, пока не появится новая задача, затем возвращаемся к пункту 1.

Это формализация того, что мы наблюдаем при просмотре веб-страниц. Движок JavaScript большую часть времени ничего не делает — он работает только тогда, когда активируется скрипт, обработчик события или другой механизм. Примеры задач:

- Когда загружается внешний скрипт `<script src="...">`, задача — выполнить его.
- Когда пользователь двигает мышь, задача — вызвать событие `mousemove` и выполнить обработчики.
- Когда срабатывает `setTimeout`, задача — выполнить его колбэк.
- И так далее.

Задачи поступают в очередь, движок их обрабатывает, а затем снова засыпает, потребляя минимальное количество процессорных ресурсов. Давайте теперь рассмотрим, как это работает на серверной стороне.

![[Pasted image 20250302055001.png]]

# Память и выполнение кода в JavaScript

В JavaScript управление памятью и выполнение кода организованы с помощью нескольких ключевых компонентов:

## Память (Memory Heap)

**Memory Heap** — это область памяти, где размещаются объекты. Она представляет собой большую, в основном неструктурированную область памяти, используемую для динамического распределения памяти, то есть для хранения объектов и данных, создаваемых во время выполнения программы.

## Стек вызовов (Call Stack)

**Call Stack** — это структура данных, представляющая собой стек кадров (frames), где каждый кадр соответствует вызову функции. Поскольку JavaScript является однопоточным языком, стек вызовов используется для отслеживания всех операций, ожидающих выполнения. Когда функция завершается, она удаляется из стека. Стек работает по принципу LIFO (Last In, First Out), то есть последняя вошедшая функция выходит первой.

## Встроенные API браузера (Browser or Web APIs)

**Browser or Web APIs** — это интерфейсы, встроенные в веб-браузер, которые предоставляют доступ к данным браузера и окружению компьютера, позволяя выполнять сложные операции. Они не являются частью самого языка JavaScript, а построены поверх него, предоставляя дополнительные возможности для использования в коде JavaScript.

Например, Geolocation API предоставляет простые конструкции JavaScript для получения данных о местоположении, что позволяет, например, отображать ваше местоположение на карте Google. В фоновом режиме браузер использует сложный низкоуровневый код (например, на C++) для взаимодействия с GPS-оборудованием устройства (или другими доступными средствами определения местоположения), получения данных о позиции и передачи их обратно в среду браузера для использования в вашем коде. Однако эта сложность скрыта от вас благодаря API.

## Очередь событий или колбэков (Event or Callback Queue)

**Event or Callback Queue** — это структура данных, ответственная за отправку новых функций в стек для обработки. Она следует принципу очереди (FIFO — First In, First Out), чтобы поддерживать правильную последовательность, в которой все операции должны быть отправлены на выполнение. Когда стек вызовов освобождается, функции из очереди событий перемещаются в стек для выполнения, обеспечивая асинхронное поведение JavaScript.

![[Pasted image 20250302055634.png]]

![[Pasted image 20250302055655.png]]


# Асинхронные функции и цикл событий в JavaScript

Когда вызывается **асинхронная функция**, она передаётся в **API браузера**. Эти API встроены в браузер и выполняют свои операции в **отдельных потоках** от основного выполнения JavaScript-кода.

### Пример работы `setTimeout`

Одним из примеров является метод `setTimeout`. Когда `setTimeout` попадает в **стек вызовов (Call Stack)**, он передаётся в соответствующий **API браузера**, который ждёт указанное время, а затем отправляет эту операцию обратно для обработки.

**Куда отправляется операция после завершения таймера?**  
В **очередь событий (Event Queue)**. Таким образом, асинхронные операции в JavaScript работают по **циклическому принципу**:

1. Язык **однопоточный**, но API браузера работают в **отдельных потоках**.
2. **Цикл событий (Event Loop)** управляет этим процессом:
   - Он следит за стеком вызовов и очередью событий.
   - Если стек вызовов **пуст**, он забирает первую задачу из **очереди событий** и отправляет её в стек.
   - Если стек вызовов **не пуст**, текущая функция продолжает выполняться.

### Пример кода и разбор его выполнения

```javascript
const foo = () => console.log("First");
const bar = () => setTimeout(() => console.log("Second"), 500);
const baz = () => console.log("Third");

bar();
foo();
baz();

```
[[https://towardsdev.com/event-loop-in-javascript-672c07618dc9|Cсылка на gif]]
![[Event-loop.gif]]
# Разбор работы Event Loop: Микрозадачи и Макрозадачи

При вызове `bar()`, он возвращает `setTimeout`, который передаётся в **Web API**. После этого `setTimeout` и `bar` удаляются из **стека вызовов (Call Stack)**.

1. **Запускается таймер** `setTimeout`, а тем временем:
   - `foo()` выполняется и выводит `"First"`, затем завершается.
   - `baz()` выполняется, добавляет свой коллбэк в **очередь задач (Event Queue)** и выводит `"Third"`.
   - После завершения `baz()`, **стек вызовов пуст**, поэтому Event Loop добавляет коллбэк из очереди в стек.
   - `console.log("Second")` выполняется.

## Виды задач в Event Loop

### 1. **Микрозадачи (Micro-tasks)**

Микрозадачи выполняются **после завершения текущего скрипта** и **до возврата управления Event Loop'у**.  
Если во время выполнения одной микрозадачи добавляются новые микрозадачи, они также выполняются перед переходом к следующей макрозадаче.  

📌 **Приоритет микрозадач выше, чем у макрозадач.**  
После выполнения **каждой макрозадачи** Event Loop **полностью очищает очередь микрозадач**, прежде чем вернуться к макрозадачам.

### 🔹 Примеры микрозадач:
- `queueMicrotask()`
- `Promise.then()`
- `MutationObserver`
- `process.nextTick()` (в Node.js)

### 🔹 Синтаксис добавления микрозадачи:
```javascript
queueMicrotask(() => {
    console.log("Это микрозадача");
});
```


### **Макрозадачи (Macro-tasks)**

Макрозадачи — это **независимые операции**, такие как выполнение кода, обработка сетевых запросов или отрисовка интерфейса.

📌 **После каждой макрозадачи выполняются все микрозадачи, а затем берётся следующая макрозадача.**

### 🔹 Примеры макрозадач:

- `setTimeout()`
- `setInterval()`
- `setImmediate()` (в Node.js)
- `requestAnimationFrame()`
- **Обработчики событий** (клики, ввод, загрузка страницы)
- **Сетевые запросы** (AJAX, Fetch, WebSocket)

---

## Пример работы микрозадач и макрозадач


```javascript


console.log("Task 1");  
setTimeout(() => console.log("Task 5 (macro)"), 0);  
queueMicrotask(() => console.log("Task 2 (micro)"));  Promise.resolve().then(() => console.log("Task 3 (micro)"));  console.log("Task 4");
```

### 🔹 Ожидаемый вывод:


```javascript

Task 1 
Task 4 
Task 2 (micro) 
Task 3 (micro) 
Task 5 (macro)
```

### 🔹 Разбор работы кода:

1. `console.log("Task 1")` выполняется сразу.
2. `setTimeout()` ставит `Task 5` в **очередь макрозадач**.
3. `queueMicrotask()` и `Promise.then()` добавляют `Task 2` и `Task 3` в **очередь микрозадач**.
4. `console.log("Task 4")` выполняется сразу.
5. **Очередь микрозадач обрабатывается**:
    - `Task 2 (micro)`
    - `Task 3 (micro)`
6. **Event Loop берёт следующую макрозадачу** → `Task 5 (macro)`

![[Queues-in-loop.gif]]

Сначала `Task1` вернула значение и была удалена из стека вызовов. Затем движок проверил задачи, находящиеся в очереди микрозадач. Когда все микрозадачи были добавлены в стек вызовов и затем удалены, движок проверил задачи в очереди макрозадач, которые были помещены в стек вызовов и удалены после возврата значения.

Давайте рассмотрим это на реальном коде:

![[Pasted image 20250302061514.png]]
В этом коде у нас есть макрозадача `setTimeout` и микрозадача `promise.then()` callback. Давайте разберем выполнение кода пошагово и посмотрим, что будет выведено в консоль:

На первой строке движок встречает метод `console.log()`. Он добавляется в стек вызовов, после чего выводит в консоль значение `"Start!"`. Затем метод удаляется из стека вызовов, и движок продолжает выполнение.

Движок встречает метод `setTimeout`, который добавляется в стек вызовов. `setTimeout` является встроенным методом браузера: его callback-функция `(() => console.log('Timeout!'))` будет отправлена в **Web API** до окончания таймера. Несмотря на то, что мы передали значение `0` в таймер, callback сначала отправляется в **Web API**, а затем добавляется в очередь макрозадач: `setTimeout` — это **макрозадача**!
![[setTimeout.gif]] ![[setTimeout-2.gif]]
- Движок встречает метод `Promise.resolve()`. Он добавляется в стек вызовов, после чего выполняется и возвращает значение `"Promise!"`. Его `then` callback-функция добавляется в очередь **микрозадач**.
    
- Движок встречает метод `console.log()`. Он сразу же добавляется в стек вызовов, после чего выводит в консоль значение `"End!"`, затем удаляется из стека вызовов, и движок продолжает выполнение.
![[Promise-1.gif]] ![[Promise-2.gif]]

- Движок видит, что стек вызовов теперь пуст. Так как стек пуст, он проверяет, есть ли задачи в очереди **микрозадач**. И да, там ждет `then` callback промиса! Он добавляется в стек вызовов, после чего выводит в консоль разрешенное значение промиса — строку `"Promise!"`.
    
- Движок снова проверяет стек вызовов, который остается пустым, и еще раз смотрит в очередь **микрозадач**, но там больше нет задач. Теперь он проверяет очередь **макрозадач** — `setTimeout` callback все еще там ждет! Callback `setTimeout` добавляется в стек вызовов. Его выполнение вызывает метод `console.log()`, который выводит строку `"Timeout!"`. После этого callback `setTimeout` удаляется из стека вызовов.

![[CallStack-1.gif]] ![[CallStack-2.gif]]
## # Async/Await
![[Async-Await.gif]]

Сначала движок встречает `console.log()`. Он добавляется в стек вызовов, после чего в консоль выводится `"Before function!"`, а затем удаляется из стека.

Далее мы вызываем `async`-функцию `myFunc()`, и её тело начинает выполняться. На первой строке внутри тела функции снова вызывается `console.log()` со строкой `"In function!"`. Этот вызов добавляется в стек, затем строка выводится в консоль, и `console.log()` удаляется из стека.

Функция продолжает выполняться и доходит до следующей строки, где мы встречаем ключевое слово `await`! 🎉  
Сначала выполняется выражение, которое мы ожидаем: в данном случае это вызов функции `one()`. Она добавляется в стек вызовов, после чего возвращает **разрешённый промис**. Когда промис разрешается и `one()` возвращает значение, движок встречает `await`.

При встрече с `await` **выполнение `async`-функции приостанавливается**. ✋🏼 Остальная часть `async`-функции переносится в **очередь микрозадач**, а выполнение основного кода продолжается.

Так как `myFunc()` приостановлена, движок выходит из неё и продолжает выполнять код в том контексте, где `myFunc()` была вызвана — в **глобальном контексте выполнения**. 🏃🏽‍♀️

Когда в глобальном контексте больше **нет задач**, event loop проверяет **очередь микрозадач**. В ней находится оставшаяся часть `myFunc()`, которая теперь может продолжить выполнение.

Переменной `res` наконец-то присваивается возвращённое значение промиса — строка `"One!"`. Затем вызывается `console.log(res)`, который выводит `"One!"` в консоль и удаляется из стека вызовов. 😊

🎉 **Готово!** Обрати внимание, чем `async/await` отличается от `Promise.then()`.  
Ключевое слово `await` **приостанавливает** выполнение функции, в то время как при использовании `then()` код продолжает выполняться **без паузы**.

## **Вывод:**

Мы разобрались с **event loop** в JavaScript — это непрерывно работающий процесс, который координирует выполнение задач между **стеком вызовов** и **очередью задач**, обеспечивая асинхронность и конкурентность кода. 🚀

[[https://youtu.be/eiC58R16hb8?si=kmTwh2yaQiuWYgqM|Видосик на YouTube]]

## Дополнительно

[[https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)|Семафор]] — это механизм управления конкурентным доступом к ресурсу, который позволяет ограничить количество потоков (или задач), одновременно выполняющихся в критической секции.

В контексте **Event Loop в JavaScript**, семафор можно использовать для ограничения количества асинхронных операций, выполняемых одновременно. Поскольку JavaScript работает в **однопоточной среде**, задачи выполняются последовательно, но асинхронные операции (такие как запросы к серверу, операции с файлами в Node.js) могут выполняться параллельно с использованием **колбэков, промисов и `async/await`**.

### Как семафор помогает в Event Loop?

Event Loop обрабатывает задачи из **очереди событий (Event Queue)** и **очереди микрозадач (Microtask Queue)**. Если в коде запускается слишком много асинхронных операций одновременно (например, 1000 HTTP-запросов), это может привести к **нагрузке на систему** и **переполнению памяти**.

Использование семафора позволяет **контролировать** количество одновременно выполняющихся задач, например:

1. Разрешать выполнение **только N асинхронных операций** одновременно.
2. Ожидать завершения одной из текущих операций перед запуском новой.

### Пример реализации семафора в JavaScript

Допустим, у нас есть массив с URL-адресами, и мы хотим загружать их, но **не более 3 запросов одновременно**.

```JavaScript

class Semaphore {
  constructor(max) {
    this.max = max; // Максимальное количество одновременных задач
    this.current = 0; // Текущее количество выполняющихся задач
    this.queue = []; // Очередь ожидающих задач
  }

  async acquire() {
    if (this.current < this.max) {
      this.current++;
      return Promise.resolve();
    } else {
      return new Promise(resolve => this.queue.push(resolve));
    }
  }

  release() {
    this.current--;
    if (this.queue.length > 0) {
      const next = this.queue.shift();
      this.current++;
      next();
    }
  }
}

// Функция для имитации запроса
async function fetchData(url, semaphore) {
  await semaphore.acquire(); // Ждём свободное место в семафоре
  console.log(`Загружаем: ${url}`);
  
  await new Promise(res => setTimeout(res, Math.random() * 2000)); // Симуляция запроса
  
  console.log(`Готово: ${url}`);
  semaphore.release(); // Освобождаем место в семафоре
}

// Запуск нескольких асинхронных задач с ограничением на 3 одновременных запроса
async function run() {
  const urls = ["url1", "url2", "url3", "url4", "url5"];
  const semaphore = new Semaphore(3);
  
  const tasks = urls.map(url => fetchData(url, semaphore));
  await Promise.all(tasks);
}

run();
```

### Как это работает?

1. **`Semaphore(3)`** создаёт семафор, который позволяет выполнять не более **3 задач одновременно**.
2. **`acquire()`** либо разрешает выполнение задачи (если есть свободные "слоты"), либо ставит её в очередь ожидания.
3. **`release()`** освобождает место в семафоре и запускает следующую задачу из очереди.

### Итог

Семафор в контексте **Event Loop** помогает **контролировать количество одновременно выполняемых асинхронных операций**, предотвращая перегрузку и улучшая производительность. Это полезно, например, для **ограничения количества сетевых запросов, работы с файлами или управления соединениями с базой данных**.
