### Пример менеджера состояний в React без сторонних библиотек  
Для управления состоянием в React без Redux или Zustand можно использовать **Context API + useReducer**. Это встроенное решение, которое подходит для средних по сложности приложений.  

#### Реализация:  
```jsx
import React, { createContext, useContext, useReducer } from 'react';

// 1. Создаем контекст
const AppContext = createContext();

// 2. Начальное состояние
const initialState = {
  count: 0,
  user: null,
};

// 3. Редуктор (аналог Redux)
function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'SET_USER':
      return { ...state, user: action.payload };
    default:
      return state;
  }
}

// 4. Провайдер контекста (обертка для приложения)
export function AppProvider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
}

// 5. Хук для доступа к состоянию
export function useAppState() {
  return useContext(AppContext);
}
```

#### Использование в компоненте:  
```jsx
import { useAppState } from './AppContext';

function Counter() {
  const { state, dispatch } = useAppState();
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+1</button>
    </div>
  );
}
```

---

### Чем упрощают разработку сторонние менеджеры (Zustand/Redux)?  
1. **Производительность**:  
   - В Context API при изменении состояния перерендериваются **все** подписанные компоненты, даже если они используют только часть состояния.  
   - Zustand/Redux оптимизируют подписку и обновляют только нужные компоненты.  

2. **Инструменты разработчика**:  
   - Redux DevTools позволяют отслеживать изменения, "путешествовать" по истории состояний (time-travel debugging).  
   - Zustand тоже поддерживает DevTools.  

3. **Меньше шаблонного кода**:  
   - Redux требует boilerplate (редьюсеры, экшены, селекторы), но есть RTK (Redux Toolkit), который упрощает это.  
   - Zustand предлагает минимальный API (~15 строк для хранилища).  

4. **Продвинутые возможности**:  
   - Middleware (логирование, асинхронные операции в Redux).  
   - В Zustand — встроенная поддержка асинхронных действий.  

---

### Когда использовать сторонние менеджеры?  
1. **Большое приложение**:  
   - Десятки/сотни компонентов, сложные связи между состояниями.  
   - Пример: админ-панель с множеством фильтров, модалок, кешированием данных.  

2. **Общее состояние между несвязанными компонентами**:  
   - Например, настройки темы или данные пользователя, которые нужны в разных частях приложения.  

3. **Чаые обновления состояния**:  
   - Если состояние меняется часто (например, drag-and-drop), Context API может вызывать лишние ререндеры.  

4. **Необходимость временить**:  
   - Для отладки сложных сценариев (например, воспроизведение багов).  

---

### Когда хватит Context API + useReducer?  
- Маленькие/средние приложения.  
- Простые состояния без частых обновлений.  
- Если не хочется добавлять лишние зависимости.  

#### Примеры:  
- Тема оформления (светлая/тёмная).  
- Модальные окна (открыть/закрыть).  
- Форма с множеством полей (управление локальным состоянием).  

---

### Итог  
- **Context API + useReducer** — просто, встроено в React, но не для сложных случаев.  
- **Zustand/Redux** — мощнее, лучше масштабируются, но требуют изучения.  
Выбор зависит от проекта: для маленьких задач Context достаточно, для больших — сторонние решения сэкономят время и нервы.